<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>CorrectedX&#39;s Blog</title>
  
  <subtitle>Talk is cheap, show me the code.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://correctedx.github.io/"/>
  <updated>2020-04-22T09:33:00.891Z</updated>
  <id>http://correctedx.github.io/</id>
  
  <author>
    <name>Corrected X</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>C89标准、C99标准、C11标准的区别</title>
    <link href="http://correctedx.github.io/diff_between_C/"/>
    <id>http://correctedx.github.io/diff_between_C/</id>
    <published>2020-04-20T16:00:00.000Z</published>
    <updated>2020-04-22T09:33:00.891Z</updated>
    
    <content type="html"><![CDATA[<p>原文: <a href="https://blog.csdn.net/xieyihua1994/article/details/51340354" target="_blank" rel="noopener">经验之谈</a>, 为方便参考查看备份。</p><h2 id="C89标准与C99标准的区别"><a href="#C89标准与C99标准的区别" class="headerlink" title="C89标准与C99标准的区别"></a>C89标准与C99标准的区别</h2><p><strong>1、增加restrict指针</strong></p><p>　　C99中增加了公适用于指针的restrict类型修饰符，它是初始访问指针所指对象的惟一途径，因此只有借助restrict指针表达式才能访问对象。restrict指针指针主要用做函数变元，或者指向由malloc()函数所分配的内存变量。restrict数据类型不改变程序的语义。</p><p>　　如果某个函数定义了两个restrict指针变元，编译程序就假定它们指向两个不同的对象，memcpy()函数就是restrict指针的一个典型应用示例。</p><p>　　C89标准中memcpy()函数原型如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void *memcpy (void *s1, const void *s2, size_t size);</span><br></pre></td></tr></table></figure><p>　　如果s1和s2所指向的对象重叠，其操作就是未定义的。memcpy()函数只能用于不重叠的对象。</p><p>　　C99标准中memcpy()函数原型如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void *memcpy(void *restrict s1, const void *restrict s2,size_t size);</span><br></pre></td></tr></table></figure><p>　　通过使用restrict修饰s1和s2，可确保它们在该原型中指向不同的对象。</p><p><strong>2、inline（内联）关键字</strong></p><p>　　内联函数除了保持结构化和函数式的定义方式外，还能使程序员写出高效率的代码。函数的每次调用与返回都会消耗相当大的系统资源，尤其是当函数调用发生在重复次数很多的循环语句中时。</p><p>　　一般情况下，当发生一次函数调用时，变元需要进栈，各种寄存器内存需要保存。当函数返回时，寄存器的内容需要恢复。</p><p>　　如果该函数在代码内进行联机扩展，当代码执行时，这些保存和恢复操作会再发生，而且函数调用的执行速度也会大大加快。函数的联机扩展会产生较长的代码，所以只应该内联对应用程序性能有显著影响的函数以及长度较短的函数。</p><p><strong>3、新增数据类型</strong></p><p><em>a、_Bool</em><br>　　_Bool值是0或1。C99中增加了用来定义bool、true以及false宏的头文件stdbool.h，以便程序员能够编写同时兼容于C与C++的应用程序。在编写新的应用程序时，应该使用stdbool.h头文件中的bool宏。</p><p><em>b、_Complex and _Imaginary</em><br>　　C99标准中定义的复数类型如下：</p><blockquote><ul><li>float _Complex;</li><li>float _Imaginary;</li><li>double _Complex;</li><li>double _Imaginary;</li><li>long double _Complex;</li><li>long double _Imaginary.</li></ul></blockquote><p>　　complex.h头文件中定义了complex和imaginary宏,并将它们扩展为_Complex和_Imaginary,因此在编写新的应用程序时,应该使用stdbool.h头文件中的complex和imaginary宏。</p><p><em>c、long long int</em><br>　　C99标准中引进了long long int，[-(2e63 - 1), 2e63 - 1]和unsigned long long int，[0, 2e64 - 1]。long long int能够支持的整数长度为64位。</p><p><strong>4、对数组的增强</strong></p><p><em>a、可变长数组</em><br>　　C99中，程序员声明数组时，数组的维数可以由任一有效的整型表达式确定，包括只在运行时才能确定其值的表达式，这类数组就叫做可变长数组，但是只有局部数组才可以是变长的。</p><p>　　可变长数组的维数在数组生存期内是不变的,也就是说,可变长数组不是动态的.可以变化的只是数组的大小。可以使用*来定义不确定长的可变长数组。</p><p><em>b、数组声明中的类型修饰符</em><br>　　在C99中，如果需要使用数组作为函数变元，可以在数组声明的方括号内使用static关键字，这相当于告诉编译程序，变元所指向的数组将至少包含指定的元素个数。也可以在数组声明的方括号内使用restrict, volatile, const关键字，但只用于函数变元。如果使用restrict，指针是初始访问该对象的惟一途径。如果使用const，指针始终指向同一个数组。使用volatile没有任何意义。</p><p><strong>5、单行注释</strong></p><p>　　引入了单行注释标记 “//“ , 可以象C++一样使用这种注释了。</p><p><strong>6、分散代码与声明</strong><br><strong>7、预处理程序的修改</strong></p><p><em>a、变元列表</em><br>　　宏可以带变元，在宏定义中用省略号（…）表示。内部预处理标识符<strong>VA_ARGS</strong>决定变元将在何处得到替换。</p><p>  例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#define MySum(...) sum(__VA_ARGS__)</span><br></pre></td></tr></table></figure><p>　　语句 MySum(k,m,n); 转换成 sum(k, m, n);，变元还可以包含变元。</p><p> 例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#define compare(compf, ...) compf(__VA_ARGS__)</span><br></pre></td></tr></table></figure><p>　　语句 compare(strcmp, “small”, “large”); 替换成 strcmp(“small”,”large”);</p><p><em>ｂ、_Pragma运算符</em></p><p>　　C99引入了在程序中定义编译指令的另外一种方法：_Pragma运算符。格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Pragma(&quot;directive&quot;)</span><br></pre></td></tr></table></figure><p>　　其中directive是要满打满算的编译指令。_Pragma运算符允许编译指令参与宏替换。</p><p><em>ｃ、内部编译指令</em></p><table><thead><tr><th>内部编译指令</th><th>可选值</th><th>默认值</th><th>备注</th></tr></thead><tbody><tr><td>STDCFP_CONTRACT</td><td>ON/OFF/DEFAULT</td><td>定义工具</td><td>若为ON，浮点表达式被当做基于硬件方式处理的独立单元</td></tr><tr><td>STDCFEVN_ACCESS</td><td>ON/OFF/DEFAULT</td><td>定义工具</td><td>若为ON，告诉编译程序可以访问浮点环境</td></tr><tr><td>STDC CX_LIMITED_RANGE</td><td>ON/OFF/DEFAULT</td><td>OFF</td><td>若为ON，相当于告诉编译程序某程序某些含有复数的公式是可靠的</td></tr></tbody></table><p><em>ｄ、新增的内部宏</em></p><table><thead><tr><th>内部宏</th><th>说明</th></tr></thead><tbody><tr><td>__STDC_HOSTED__</td><td>若操作系统存在，则为1</td></tr><tr><td>__STDC_VERSION__</td><td>199991L或更高，代表C的版本</td></tr><tr><td>__STDC_IEC_599__</td><td>若支持IEC 60559浮点运算，则为1</td></tr><tr><td>__STDC_IEC_599_COMPLEX__</td><td>若支持IEC 60599复数运算，则为1</td></tr><tr><td>__STDC_ISO_10646__</td><td>由编译程序支持，定义ISO/IEC 10646标准的年月格式：yyymmmL</td></tr></tbody></table><p><strong>8、for语句内的变量声明</strong></p><p>　　C99中，程序员可以在for语句的初始化部分定义一个或多个变量，这些变量的作用域仅于本for语句所控制的循环体内。比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for( int i &#x3D; 0 ; i &lt; 10 ; i++ ) &#123;</span><br><span class="line">    &#x2F;&#x2F; do someting ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>9、复合赋值</strong></p><p>　　C99中，复合赋值中，可以指定对象类型的数组、结构或联合表达式。当使用复合赋值时，应在括弧内指定类型，后跟由花括号围起来的初始化列表；若类型为数组，则不能指定数组的大小。建成的对象是未命名的。例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">double *fp &#x3D; (double[]) &#123;1.1, 2.2, 3.3&#125;;</span><br></pre></td></tr></table></figure><p>　　该语句用于建立一个指向double的指针fp，且该指针指向这个3元素数组的第一个元素。 在文件域内建立的复合赋值只在程序的整个生存期内有效。在模块内建立的复合赋值是局部对象，在退出模块后不再存在。</p><p><strong>10、柔性数组结构成员</strong></p><p>　　C99中，结构中的最后一个元素允许是未知大小的数组，这就叫做柔性数组成员，但结构中的柔性数组成员前面必须至少一个其他成员。柔性数组成员允许结构中包含一个大小可变的数组。sizeof返回的这种结构大小不包括柔性数组的内存。包含柔性数组成员的结构用malloc()函数进行内存的动态分配，并且分配的内存应该大于结构的大小，以适应柔性数组的预期大小。</p><p><strong>11、指定的初始化符</strong></p><p>　　C99中，该特性对经常使用稀疏数组的程序员十分有用。指定的初始化符通常有两种用法：用于数组，以及用于结构和联合。用于数组的格式：[index] = vol; 其中，index表示数组的下标，vol表示本数组元素的初始化值。例： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int x[10] &#x3D; &#123;[0] &#x3D; 10, [5] &#x3D; 30&#125;;</span><br></pre></td></tr></table></figure><p>　　其中只有x[0]和x[5]得到了初始化．用于结构或联合的格式如下：</p><ul><li>member-name(成员名称)</li></ul><p>　　对结构进行指定的初始化时，允许采用简单的方法对结构中的指定成员进行初始化。例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">struct example&#123;</span><br><span class="line">int k, m, n;</span><br><span class="line">&#125; object &#x3D; &#123;m &#x3D; 10,n &#x3D; 200&#125;;</span><br></pre></td></tr></table></figure><p>　　其中，没有初始化k。对结构成员进行初始化的顺序没有限制。</p><p><strong>12、printf()和scanf()函数系列的增强</strong></p><p>　　C99中printf()和scanf()函数系列引进了处理long long int和unsigned long long int数据类型的特性。long long int 类型的格式修饰符是ll。在printf()和scanf()函数中，ll适用于d, i, o, u 和x格式说明符。另外，C99还引进了hh修饰符。当使用d, i, o, u和x格式说明符时，hh用于指定char型变元。ll和hh修饰符均可以用于n说明符。</p><p>　　格式修饰符a和A用在printf()函数中时，结果将会输出十六进制的浮点数。格式如下：[-]0xh, hhhhp + d 使用A格式修饰符时，x和p必须是大写。A和a格式修饰符也可以用在scanf()函数中，用于读取浮点数。调用printf()函数时，允许在%f说明符前加上l修饰符，即%lf，但不起作用。</p><p><strong>13、C99新增的库</strong></p><p><em>C89中标准的头文件</em></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;assert.h&gt; 定义宏assert()</span><br><span class="line">&lt;ctype.h&gt; 字符处理</span><br><span class="line">&lt;errno.h&gt; 错误报告</span><br><span class="line">&lt;float.h&gt; 定义与实现相关的浮点值勤</span><br><span class="line">&lt;limits.h&gt; 定义与实现相关的各种极限值</span><br><span class="line">&lt;locale.h&gt; 支持函数setlocale()</span><br><span class="line">&lt;math.h&gt; 数学函数库使用的各种定义</span><br><span class="line">&lt;setjmp.h&gt; 支持非局部跳转</span><br><span class="line">&lt;signal.h&gt; 定义信号值</span><br><span class="line">&lt;stdarg.h&gt; 支持可变长度的变元列表</span><br><span class="line">&lt;stddef.h&gt; 定义常用常数</span><br><span class="line">&lt;stdio.h&gt; 支持文件输入和输出</span><br><span class="line">&lt;stdlib.h&gt; 其他各种声明</span><br><span class="line">&lt;string.h&gt; 支持串函数</span><br><span class="line">&lt;time.h&gt; 支持系统时间函数</span><br></pre></td></tr></table></figure><p><em>C99新增的头文件和库</em></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;complex.h&gt; 支持复数算法</span><br><span class="line">&lt;fenv.h&gt; 给出对浮点状态标记和浮点环境的其他方面的访问</span><br><span class="line">&lt;inttypes.h&gt; 定义标准的、可移植的整型类型集合。也支持处理最大宽度整数的函数（常见）</span><br><span class="line">&lt;iso646.h&gt; 首先在此1995年第一次修订时引进，用于定义对应各种运算符的宏</span><br><span class="line">&lt;stdbool.h&gt; 支持布尔数据类型类型。定义宏bool，以便兼容于C++</span><br><span class="line">&lt;stdint.h&gt; 定义标准的、可移植的整型类型集合。该文件包含在&lt;inttypes.h&gt;中（常见）</span><br><span class="line">&lt;tgmath.h&gt; 定义一般类型的浮点宏</span><br><span class="line">&lt;wchar.h&gt; 首先在1995年第一次修订时引进，用于支持多字节和宽字节函数</span><br><span class="line">&lt;wctype.h&gt; 首先在1995年第一次修订时引进，用于支持多字节和宽字节分类函数</span><br></pre></td></tr></table></figure><p><strong>14、<strong>func</strong>预定义标识符</strong></p><p>　　用于指出<strong>func</strong>所存放的函数名，类似于字符串赋值。</p><p><strong>15、其它特性的改动</strong></p><p><em>a、放宽的转换限制</em></p><table><thead><tr><th>限制</th><th>C89标准</th><th>C99标准</th></tr></thead><tbody><tr><td>数据块的嵌套层数</td><td>15</td><td>127</td></tr><tr><td>条件语句的嵌套层数</td><td>8</td><td>63</td></tr><tr><td>内部标识符中的有效字符个数</td><td>31</td><td>63</td></tr><tr><td>外部标识符中的有效字符个数</td><td>6</td><td>31</td></tr><tr><td>结构或联合中的成员个数</td><td>127</td><td>1023</td></tr><tr><td>函数调用中的参数个数</td><td>31</td><td>127</td></tr></tbody></table><p><em>b、不再支持隐含式的int规则</em><br>　　删除了隐含式函数声明</p><p><em>c、对返回值的约束</em><br>　　C99中,非空类型函数必须使用带返回值的return语句.</p><p><em>d、扩展的整数类型</em></p><table><thead><tr><th>扩展类型</th><th>含义</th></tr></thead><tbody><tr><td>int16_t</td><td>整数长度为精确16位</td></tr><tr><td>int_least16_t</td><td>整数长度为至少16位</td></tr><tr><td>int_fast32_t</td><td>最稳固的整数类型,其长度为至少32位</td></tr><tr><td>intmax_t</td><td>最大整数类型</td></tr><tr><td>uintmax_t</td><td>最大无符号整数类型</td></tr></tbody></table><p><em>e、对整数类型提升规则的改进</em><br>　　C89中，表达式中类型为char，short int或int的值可以提升为int或unsigned int类型。</p><p>　　C99中，每种整数类型都有一个级别.例如:long long int 的级别高于int，int的级别高于char等。在表达式中，其级别低于int或unsigned int的任何整数类型均可被替换成int或unsigned int类型。</p><h2 id="C99标准与C11标准的区别"><a href="#C99标准与C11标准的区别" class="headerlink" title="C99标准与C11标准的区别"></a>C99标准与C11标准的区别</h2><p>1、对齐处理操作符 alignof，函数 aligned_alloc()，以及 头文件 stdalign.h。</p><p>2、<em>Noreturn 函数标记，类似于 gcc 的 <em>_attribute</em></em>((noreturn))。例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_Noreturn void thrd_exit(int res);</span><br></pre></td></tr></table></figure><p>3、_Generic 关键词，有点儿类似于 gcc 的 typeof。示例代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">#define GENERAL_ABS(x) _Generic((x), int:abs, float:fabsf, double:fabs)(x)</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;intabs:%d\n&quot;,GENERAL_ABS(-12));</span><br><span class="line">printf(&quot;floatabs:%f\n&quot;,GENERAL_ABS(-12.04f));</span><br><span class="line">printf(&quot;doubleabs:%f\n&quot;,GENERAL_ABS(-13.09876));</span><br><span class="line"></span><br><span class="line">int a&#x3D;10;</span><br><span class="line">int b&#x3D;0, c&#x3D;0;</span><br><span class="line"></span><br><span class="line">_Generic(a+0.1f,int:b,float:c,default:b)++;</span><br><span class="line">printf(&quot;b&#x3D;%d,c&#x3D;%d\n&quot;,b,c);</span><br><span class="line"></span><br><span class="line">_Generic(a+&#x3D;1.1f,int:b,float:c,default:b)++;</span><br><span class="line">printf(&quot;a&#x3D;%d,b&#x3D;%d,c&#x3D;%d\n&quot;,a,b,c);</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4、静态断言（ static assertions ），_Static_assert()，在解释 #if 和 #error 之后被处理。例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_Static_assert(FOO &gt; 0, &quot;FOO has a wrong value&quot;);</span><br></pre></td></tr></table></figure><p>5、删除了 gets() 函数，C99中已经将此函数被标记为过时，推荐新的替代函数 gets_s()。</p><p>6、新的 fopen() 模式，(“…x”)。类似 POSIX 中的 O_CREAT|O_EXCL，在文件锁中比较常用。</p><p>7、匿名结构体/联合体，这个早已经在 gcc 中了。</p><p>8、多线程支持，包括：_Thread_local，头文件 threads.h，里面包含线程的创建和管理函数（比如 thrd_create()，thrd_exit()），mutex （比如 mtx_lock()，mtx_unlock()）等等。</p><p>9、_Atomic类型修饰符和 头文件 stdatomic.h。</p><p>10、带边界检查（Bounds-checking）的函数接口，定义了新的安全的函数，例如 fopen_s()，strcat_s() 等等。更多参考 Annex K。</p><p>11、改进的 Unicode 支持，新的头文件 uchar.h 等。例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;uchar.h&gt;</span><br><span class="line"> </span><br><span class="line">size_t UTF16StrLen(const char16_t *utf16String)</span><br><span class="line">&#123;</span><br><span class="line">if(utf16String &#x3D;&#x3D; NULL)</span><br><span class="line">return 0;</span><br><span class="line"> </span><br><span class="line">size_t index;</span><br><span class="line"></span><br><span class="line">for( index &#x3D;  0; utf16String[index] !&#x3D; u&#39;\0&#39; ; index++ );</span><br><span class="line"></span><br><span class="line">return index;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">size_t UTF16ToUTF8(char *mbBuffer, const char16_t *utf16String)</span><br><span class="line">&#123;</span><br><span class="line">if( mbBuffer &#x3D;&#x3D; NULL || utf16String &#x3D;&#x3D; NULL )</span><br><span class="line">return 0;</span><br><span class="line"></span><br><span class="line">mbstate_t state &#x3D; &#123;&#125;;</span><br><span class="line"></span><br><span class="line">size_t mbIndex&#x3D;0;</span><br><span class="line"></span><br><span class="line">for( int utf16Index &#x3D; 0; utf16String[utf16Index] !&#x3D; u&#39;\0&#39; ; utf16Index++ )</span><br><span class="line">&#123;</span><br><span class="line">const size_t length &#x3D; c16rtomb(&amp;mbBuffer[mbIndex], utf16String[utf16Index], &amp;state);</span><br><span class="line">mbIndex +&#x3D; length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">mbBuffer[mbIndex] &#x3D; &#39;\0&#39;;</span><br><span class="line"></span><br><span class="line">return mbIndex;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">char16_t ch &#x3D; u&#39;好&#39;;</span><br><span class="line">char chBuffer[64];</span><br><span class="line">mbstate_t state&#x3D;&#123;&#125;;</span><br><span class="line"></span><br><span class="line">size_t length &#x3D; c16rtomb(chBuffer, ch, &amp;state);</span><br><span class="line">chBuffer[length] &#x3D; &#39;\0&#39;;</span><br><span class="line">printf(&quot;TheUTF-8characterlengthis:%zu,andthecharacteris:%s\n&quot;, length, chBuffer);</span><br><span class="line"></span><br><span class="line">const char *utf8Str &#x3D; u8&quot;你好，世界。&quot;;</span><br><span class="line">printf(&quot;TheUTF-8stringis:%s\n&quot;, utf8Str);</span><br><span class="line"></span><br><span class="line">const char16_t *utf16Str &#x3D; u&quot;你好，世界。&quot;;</span><br><span class="line">printf(&quot;Theutf16stringlengthis:%zu\n&quot;, UTF16StrLen(utf16Str));</span><br><span class="line"></span><br><span class="line">length &#x3D; UTF16ToUTF8(chBuffer, utf16Str);</span><br><span class="line">printf(&quot;TheUTF-8stringlengthis:%zu,andthecontentis:%s\n&quot;, length, chBuffer);</span><br><span class="line"></span><br><span class="line">printf(&quot;IftheconvertedUTF-8stringisequaltotheoriginalone?%s\n&quot;, strcmp(chBuffer,utf8Str) &#x3D;&#x3D; 0 ? &quot;YES&quot; : &quot;NO&quot;);</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>12、新增 quick_exit() 函数，作为第三种终止程序的方式，当 exit() 失败时可以做最少的清理工作（deinitializition）。</p><p>13、创建复数的宏， CMPLX()。</p><p>14、更多浮点数处理的宏 （More macros for querying the characteristics of floating point types, concerning subnormal floating point numbers and the number of decimal digits the type is able to store）。</p><p>15、struct timespec 成为 time.h 的一部分，以及宏 TIME_UTC，函数 timespec_get()。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;原文: &lt;a href=&quot;https://blog.csdn.net/xieyihua1994/article/details/51340354&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;经验之谈&lt;/a&gt;, 为方便参考查看备份。&lt;/p&gt;
&lt;h2 id=
      
    
    </summary>
    
    
    
      <category term="C" scheme="http://correctedx.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>Hexo页面效果测试页</title>
    <link href="http://correctedx.github.io/test-hexo/"/>
    <id>http://correctedx.github.io/test-hexo/</id>
    <published>2020-04-20T16:00:00.000Z</published>
    <updated>2020-04-21T11:40:24.627Z</updated>
    
    <content type="html"><![CDATA[<p>本页面用于测试hexo搭建的个站展示效果及各种插件。</p><p>@<a href="这里写自定义目录标题">TOC</a></p><h2 id="Markdown语法测试-CSDN语法提示"><a href="#Markdown语法测试-CSDN语法提示" class="headerlink" title="Markdown语法测试(CSDN语法提示)"></a>Markdown语法测试(CSDN语法提示)</h2><p>你好！ 这是你第一次使用 <strong>Markdown编辑器</strong> 所展示的欢迎页。如果你想学习如何使用Markdown编辑器, 可以仔细阅读这篇文章，了解一下Markdown的基本语法知识。</p><h2 id="新的改变"><a href="#新的改变" class="headerlink" title="新的改变"></a>新的改变</h2><p>我们对Markdown编辑器进行了一些功能拓展与语法支持，除了标准的Markdown编辑器功能，我们增加了如下几点新功能，帮助你用它写博客：</p><ol><li><strong>全新的界面设计</strong> ，将会带来全新的写作体验；</li><li>在创作中心设置你喜爱的代码高亮样式，Markdown <strong>将代码片显示选择的高亮样式</strong> 进行展示；</li><li>增加了 <strong>图片拖拽</strong> 功能，你可以将本地的图片直接拖拽到编辑区域直接展示；</li><li>全新的 <strong>KaTeX数学公式</strong> 语法；</li><li>增加了支持<strong>甘特图的mermaid语法<a href="[mermaid语法说明](https://mermaidjs.github.io/)">^1</a></strong> 功能；</li><li>增加了 <strong>多屏幕编辑</strong> Markdown文章功能；</li><li>增加了 <strong>焦点写作模式、预览模式、简洁写作模式、左右区域同步滚轮设置</strong> 等功能，功能按钮位于编辑区域与预览区域中间；</li><li>增加了 <strong>检查列表</strong> 功能。</li></ol><h2 id="功能快捷键"><a href="#功能快捷键" class="headerlink" title="功能快捷键"></a>功能快捷键</h2><p>撤销：<kbd>Ctrl/Command</kbd> + <kbd>Z</kbd><br>重做：<kbd>Ctrl/Command</kbd> + <kbd>Y</kbd><br>加粗：<kbd>Ctrl/Command</kbd> + <kbd>B</kbd><br>斜体：<kbd>Ctrl/Command</kbd> + <kbd>I</kbd><br>标题：<kbd>Ctrl/Command</kbd> + <kbd>Shift</kbd> + <kbd>H</kbd><br>无序列表：<kbd>Ctrl/Command</kbd> + <kbd>Shift</kbd> + <kbd>U</kbd><br>有序列表：<kbd>Ctrl/Command</kbd> + <kbd>Shift</kbd> + <kbd>O</kbd><br>检查列表：<kbd>Ctrl/Command</kbd> + <kbd>Shift</kbd> + <kbd>C</kbd><br>插入代码：<kbd>Ctrl/Command</kbd> + <kbd>Shift</kbd> + <kbd>K</kbd><br>插入链接：<kbd>Ctrl/Command</kbd> + <kbd>Shift</kbd> + <kbd>L</kbd><br>插入图片：<kbd>Ctrl/Command</kbd> + <kbd>Shift</kbd> + <kbd>G</kbd></p><h2 id="合理的创建标题，有助于目录的生成"><a href="#合理的创建标题，有助于目录的生成" class="headerlink" title="合理的创建标题，有助于目录的生成"></a>合理的创建标题，有助于目录的生成</h2><p>直接输入1次<kbd>#</kbd>，并按下<kbd>space</kbd>后，将生成1级标题。<br>输入2次<kbd>#</kbd>，并按下<kbd>space</kbd>后，将生成2级标题。<br>以此类推，我们支持6级标题。有助于使用<code>TOC</code>语法后生成一个完美的目录。</p><h2 id="如何改变文本的样式"><a href="#如何改变文本的样式" class="headerlink" title="如何改变文本的样式"></a>如何改变文本的样式</h2><p><em>强调文本</em> <em>强调文本</em></p><p><strong>加粗文本</strong> <strong>加粗文本</strong></p><p>==标记文本==</p><p><del>删除文本</del></p><blockquote><p>引用文本</p></blockquote><p>H<del>2</del>O is是液体。</p><p>2^10^ 运算结果是 1024.</p><h2 id="插入链接与图片"><a href="#插入链接与图片" class="headerlink" title="插入链接与图片"></a>插入链接与图片</h2><p>链接: <a href="https://mp.csdn.net" target="_blank" rel="noopener">link</a>.</p><p>图片: <img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9hdmF0YXIuY3Nkbi5uZXQvNy83L0IvMV9yYWxmX2h4MTYzY29tLmpwZw?x-oss-process=image/format,png" alt="Alt"></p><p>带尺寸的图片: ![Alt](<a href="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9hdmF0YXIuY3Nkbi5uZXQvNy83L0IvMV9yYWxmX2h4MTYzY29tLmpwZw?x-oss-process=image/format,png#" target="_blank" rel="noopener">https://imgconvert.csdnimg.cn/aHR0cHM6Ly9hdmF0YXIuY3Nkbi5uZXQvNy83L0IvMV9yYWxmX2h4MTYzY29tLmpwZw?x-oss-process=image/format,png#</a> =30x30)</p><p>居中的图片: <img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9hdmF0YXIuY3Nkbi5uZXQvNy83L0IvMV9yYWxmX2h4MTYzY29tLmpwZw?x-oss-process=image/format,png#pic_center" alt="Alt"></p><p>居中并且带尺寸的图片: ![Alt](<a href="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9hdmF0YXIuY3Nkbi5uZXQvNy83L0IvMV9yYWxmX2h4MTYzY29tLmpwZw?x-oss-process=image/format,png#pic_center" target="_blank" rel="noopener">https://imgconvert.csdnimg.cn/aHR0cHM6Ly9hdmF0YXIuY3Nkbi5uZXQvNy83L0IvMV9yYWxmX2h4MTYzY29tLmpwZw?x-oss-process=image/format,png#pic_center</a> =30x30)</p><p>当然，我们为了让用户更加便捷，我们增加了图片拖拽功能。</p><h2 id="如何插入一段漂亮的代码片"><a href="#如何插入一段漂亮的代码片" class="headerlink" title="如何插入一段漂亮的代码片"></a>如何插入一段漂亮的代码片</h2><p>去<a href="https://mp.csdn.net/configure" target="_blank" rel="noopener">博客设置</a>页面，选择一款你喜欢的代码片高亮样式，下面展示同样高亮的 <code>代码片</code>.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">1</span>: repeat</span><br><span class="line"> <span class="number">2</span>:     draw(i, p, q)<span class="keyword">from</span> A1</span><br><span class="line"> <span class="number">3</span>:     x&lt;=y&lt;=z</span><br><span class="line"> <span class="number">4</span>:     <span class="keyword">for</span> <span class="number">1</span> &lt; k &lt; K do</span><br><span class="line"> <span class="number">5</span>:         u&lt;=u+a</span><br><span class="line"> <span class="number">6</span>:         v&lt;=v+a</span><br><span class="line"> <span class="number">7</span>:         v&lt;=v+a</span><br><span class="line"> <span class="number">8</span>:         b&lt;=b+a</span><br><span class="line"> <span class="number">9</span>:         b&lt;=b+a</span><br><span class="line"><span class="number">10</span>:     end <span class="keyword">for</span></span><br><span class="line"><span class="number">11</span>: until convergence</span><br></pre></td></tr></table></figure><h2 id="生成一个适合你的列表"><a href="#生成一个适合你的列表" class="headerlink" title="生成一个适合你的列表"></a>生成一个适合你的列表</h2><ul><li>项目<ul><li>项目<ul><li>项目</li></ul></li></ul></li></ul><ol><li>项目1</li><li>项目2</li><li>项目3</li></ol><ul><li><input disabled="" type="checkbox"> 计划任务</li><li><input checked="" disabled="" type="checkbox"> 完成任务</li></ul><h2 id="创建一个表格"><a href="#创建一个表格" class="headerlink" title="创建一个表格"></a>创建一个表格</h2><p>一个简单的表格是这么创建的：<br>项目     | Value<br>——– | —–<br>电脑  | $1600<br>手机  | $12<br>导管  | $1</p><h3 id="设定内容居中、居左、居右"><a href="#设定内容居中、居左、居右" class="headerlink" title="设定内容居中、居左、居右"></a>设定内容居中、居左、居右</h3><p>使用<code>:---------:</code>居中<br>使用<code>:----------</code>居左<br>使用<code>----------:</code>居右<br>| 第一列       | 第二列         | 第三列        |<br>|:———–:| ————-:|:————-|<br>| 第一列文本居中 | 第二列文本居右  | 第三列文本居左 | </p><h3 id="SmartyPants"><a href="#SmartyPants" class="headerlink" title="SmartyPants"></a>SmartyPants</h3><p>SmartyPants将ASCII标点字符转换为“智能”印刷标点HTML实体。例如：<br>|    TYPE   |ASCII                          |HTML<br>|—————-|——————————-|—————————–|<br>|Single backticks|<code>&#39;Isn&#39;t this fun?&#39;</code>            |’Isn’t this fun?’            |<br>|Quotes          |<code>&quot;Isn&#39;t this fun?&quot;</code>            |”Isn’t this fun?”            |<br>|Dashes          |<code>-- is en-dash, --- is em-dash</code>|– is en-dash, — is em-dash|</p><h2 id="创建一个自定义列表"><a href="#创建一个自定义列表" class="headerlink" title="创建一个自定义列表"></a>创建一个自定义列表</h2><dl><dt>Markdown</dt><dd>Text-to-HTML conversion tool</dd></dl><dl><dt>Authors<br>:  John</dt><dd>Luke</dd></dl><h2 id="如何创建一个注脚"><a href="#如何创建一个注脚" class="headerlink" title="如何创建一个注脚"></a>如何创建一个注脚</h2><p>一个具有注脚的文本。<a href="注脚的解释">^2</a></p><h2 id="注释也是必不可少的"><a href="#注释也是必不可少的" class="headerlink" title="注释也是必不可少的"></a>注释也是必不可少的</h2><p>Markdown将文本转换为 HTML。</p><p>*[HTML]:   超文本标记语言</p><h2 id="KaTeX数学公式"><a href="#KaTeX数学公式" class="headerlink" title="KaTeX数学公式"></a>KaTeX数学公式</h2><p>您可以使用渲染LaTeX数学表达式 <a href="https://khan.github.io/KaTeX/" target="_blank" rel="noopener">KaTeX</a>:</p><p>Gamma公式展示 $\Gamma(n) = (n-1)!\quad\forall<br>n\in\mathbb N$ 是通过欧拉积分</p><p>$$<br>\Gamma(z) = \int_0^\infty t^{z-1}e^{-t}dt,.<br>$$</p><blockquote><p>你可以找到更多关于的信息 <strong>LaTeX</strong> 数学表达式<a href="http://meta.math.stackexchange.com/questions/5020/mathjax-basic-tutorial-and-quick-reference" target="_blank" rel="noopener">here</a>.</p></blockquote><h2 id="新的甘特图功能，丰富你的文章"><a href="#新的甘特图功能，丰富你的文章" class="headerlink" title="新的甘特图功能，丰富你的文章"></a>新的甘特图功能，丰富你的文章</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">gantt</span><br><span class="line">        dateFormat  YYYY-MM-DD</span><br><span class="line">        title Adding GANTT diagram functionality to mermaid</span><br><span class="line">        section 现有任务</span><br><span class="line">        已完成               :done,    des1, 2014-01-06,2014-01-08</span><br><span class="line">        进行中               :active,  des2, 2014-01-09, 3d</span><br><span class="line">        计划一               :         des3, after des2, 5d</span><br><span class="line">        计划二               :         des4, after des3, 5d</span><br></pre></td></tr></table></figure><ul><li>关于 <strong>甘特图</strong> 语法，参考 <a href="https://mermaidjs.github.io/" target="_blank" rel="noopener">这儿</a>,</li></ul><h2 id="UML-图表"><a href="#UML-图表" class="headerlink" title="UML 图表"></a>UML 图表</h2><p>可以使用UML图表进行渲染。 <a href="https://mermaidjs.github.io/" target="_blank" rel="noopener">Mermaid</a>. 例如下面产生的一个序列图：:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">sequenceDiagram</span><br><span class="line">张三 -&gt;&gt; 李四: 你好！李四, 最近怎么样?</span><br><span class="line">李四--&gt;&gt;王五: 你最近怎么样，王五？</span><br><span class="line">李四--x 张三: 我很好，谢谢!</span><br><span class="line">李四-x 王五: 我很好，谢谢!</span><br><span class="line">Note right of 王五: 李四想了很长时间, 文字太长了&lt;br&#x2F;&gt;不适合放在一行.</span><br><span class="line"></span><br><span class="line">李四--&gt;&gt;张三: 打量着王五...</span><br><span class="line">张三-&gt;&gt;王五: 很好... 王五, 你怎么样?</span><br></pre></td></tr></table></figure><p>这将产生一个流程图。:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">A[长方形] -- 链接 --&gt; B((圆))</span><br><span class="line">A --&gt; C(圆角长方形)</span><br><span class="line">B --&gt; D&#123;菱形&#125;</span><br><span class="line">C --&gt; D</span><br></pre></td></tr></table></figure><ul><li>关于 <strong>Mermaid</strong> 语法，参考 <a href="https://mermaidjs.github.io/" target="_blank" rel="noopener">这儿</a>,</li></ul><h2 id="FLowchart流程图"><a href="#FLowchart流程图" class="headerlink" title="FLowchart流程图"></a>FLowchart流程图</h2><p>我们依旧会支持flowchart的流程图：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">flowchat</span><br><span class="line">st&#x3D;&gt;start: 开始</span><br><span class="line">e&#x3D;&gt;end: 结束</span><br><span class="line">op&#x3D;&gt;operation: 我的操作</span><br><span class="line">cond&#x3D;&gt;condition: 确认？</span><br><span class="line"></span><br><span class="line">st-&gt;op-&gt;cond</span><br><span class="line">cond(yes)-&gt;e</span><br><span class="line">cond(no)-&gt;op</span><br></pre></td></tr></table></figure><ul><li>关于 <strong>Flowchart流程图</strong> 语法，参考 <a href="http://adrai.github.io/flowchart.js/" target="_blank" rel="noopener">这儿</a>.</li></ul><h2 id="导出与导入"><a href="#导出与导入" class="headerlink" title="导出与导入"></a>导出与导入</h2><h3 id="导出"><a href="#导出" class="headerlink" title="导出"></a>导出</h3><p>如果你想尝试使用此编辑器, 你可以在此篇文章任意编辑。当你完成了一篇文章的写作, 在上方工具栏找到 <strong>文章导出</strong> ，生成一个.md文件或者.html文件进行本地保存。</p><h3 id="导入"><a href="#导入" class="headerlink" title="导入"></a>导入</h3><p>如果你想加载一篇你写过的.md文件或者.html文件，在上方工具栏可以选择导入功能进行对应扩展名的文件导入，<br>继续你的创作。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本页面用于测试hexo搭建的个站展示效果及各种插件。&lt;/p&gt;
&lt;p&gt;@&lt;a href=&quot;这里写自定义目录标题&quot;&gt;TOC&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;Markdown语法测试-CSDN语法提示&quot;&gt;&lt;a href=&quot;#Markdown语法测试-CSDN语法提示&quot; class
      
    
    </summary>
    
    
    
      <category term="test" scheme="http://correctedx.github.io/tags/test/"/>
    
      <category term="default" scheme="http://correctedx.github.io/tags/default/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://correctedx.github.io/hello-world/"/>
    <id>http://correctedx.github.io/hello-world/</id>
    <published>2020-04-19T16:00:00.000Z</published>
    <updated>2020-04-21T11:40:49.001Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
    
    
      <category term="test" scheme="http://correctedx.github.io/tags/test/"/>
    
      <category term="default" scheme="http://correctedx.github.io/tags/default/"/>
    
  </entry>
  
</feed>
